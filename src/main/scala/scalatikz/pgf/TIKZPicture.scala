/*
 *
 *    ____         __    ____________ ______
 *   / __/______ _/ /__ /_  __/  _/ //_/_  /
 *  _\ \/ __/ _ `/ / _ `// / _/ // ,<   / /_
 * /___/\__/\_,_/_/\_,_//_/ /___/_/|_| /___/
 *
 * A PGF/TIKZ plot library for Scala.
 *     
 */

package scalatikz.pgf

import java.awt.Desktop
import java.awt.image.RenderedImage
import java.io.{File, PrintStream}
import java.nio.file.{Files, Paths, StandardCopyOption}
import javax.imageio.ImageIO
import org.ghost4j.document.PDFDocument
import org.ghost4j.renderer.SimpleRenderer
import scala.io.Source
import scala.util.{Failure, Try}
import scalatikz.common.Logging
import scalatikz.pgf.Compiler._
import sys.process._

/**
  * TIKZ picture is the environment that contains (possibly) a sequence
  * of pgf graphic elements to be compiled.
  */
trait TIKZPicture extends Logging {

  val name: String
  protected val libraries: String
  protected val scale: Int = 1
  protected val nodeDistance: Double = 2
  protected val tiKZArgs: List[String] = Nil

  private val path = new File(System.getProperty("java.io.tmpdir"))
  private val texFile: File = new File(s"$path/source.tex")

  private val devNullLogger =
    ProcessLogger(msg => logger.debug(msg), msg => if (!msg.contains("$TERM")) logger.error(msg))

  // Keep scale to 2. It seems much cleaner.
  private def asTex: String =
    raw"""
       |\documentclass{standalone}
       |
       |\usepackage{luatex85}
       |\usepackage{tikz,pgfplots}
       |$libraries
       |\pgfplotsset{compat=newest}
       |
       |\begin{document}
       |\pagestyle{empty}
       |\begin{tikzpicture}[scale=$scale, node distance=${nodeDistance}cm,${tiKZArgs.mkString(",")}]
       |${this.toString}
       |\end{tikzpicture}
       |\end{document}
    """.stripMargin

  /**
    * Compile the TIKZ picture into a PDF.
    *
    * @return a file for the generated PDF
    */
  private def compilePDF(compiler: Compiler = PDF_LATEX): File = {
    if (!path.exists) path.mkdir

    val stream: PrintStream = new PrintStream(texFile)
    stream println asTex
    stream.close()

    using(new PrintStream(s"$path/pgf-pie.sty")) { outputStream =>
      val styStream = getClass.getClassLoader.getResourceAsStream("pgf-pie.sty")
      if (styStream == null)
        s"cp ./src/main/resources/pgf-pie.sty $path" ! devNullLogger
      else using(Source.fromInputStream(styStream)) {
        _.getLines.foreach(outputStream.println)
      }
    }

    s"$compiler --shell-escape -output-directory $path ${texFile.getAbsolutePath}" ! devNullLogger

    if (!Files.exists(Paths.get(s"$path/source.pdf"))) fatal {
      using(Source.fromFile(s"$path/source.log")) { _.getLines.find(_.startsWith("!")) match {
          case Some(error) => error.drop(2)
          case None => "PDF was not generated but no errors exists in the logs."
        }
      }
    }

    s"rm $path/pgf-pie.sty" ! devNullLogger
    s"rm $path/source.aux $path/source.log $path/source.tex" ! devNullLogger
    s"mv $path/source.pdf $path/$name.pdf" ! devNullLogger

    new File(s"$path/$name.pdf")
  }

  /**
    * Generate and open the resulted figure as PDF using the default
    * desktop application used for PDFs.
    */
  final def show(compiler: Compiler = PDF_LATEX): Unit = Try(Desktop.getDesktop.open(compilePDF(compiler))) match {
    case Failure(ex) =>
      logger.warn(s"Cannot open PDF: ${ex.getMessage}")
    case _ =>
  }

  /**
    * Save a PDF generated by the TIKZ picture into the given path.
    *
    * @param path a path to save the generated PDF
    * @return a Try holding the saved PDF file. In case of non-fatal
    *         exception, a Failure object is returned holding the exception.
    */
  final def saveAsPDF(path: String, compiler: Compiler = PDF_LATEX): Try[File] = Try {
    Files.move(
      Paths.get(compilePDF(compiler).getAbsolutePath),
      Paths.get(s"$path/$name.pdf"),
      StandardCopyOption.REPLACE_EXISTING
    )

    new File(s"$path/$name.pdf")
  }

  /**
    * Save a TeX generated by the TIKZ picture into the given path.
    *
    * @param path a path to save the generated TeX file
    * @return a Try holding the saved TeX file. In case of non-fatal
    *         exception, a Failure object is returned holding the exception.
    */
  final def saveAsTeX(path: String): Try[File] = Try {
    val stream: PrintStream = new PrintStream(s"$path/$name.tex")
    stream println asTex
    stream.close()

    new File(s"$path/$name.tex")
  }

  /**
    * Save a PNG generated by the TIKZ picture into the given path.
    *
    * @param path a path to save the generated PNG
    * @return a Try holding the saved PNG file. In case of non-fatal
    *         exception, a Failure object is returned holding the exception.
    */
  final def saveAsPNG(path: String, compiler: Compiler = PDF_LATEX): Try[File] = Try {
    // load PDF document
    val doc = new PDFDocument()
    doc.load(compilePDF(compiler))

    // create renderer
    val renderer = new SimpleRenderer()
    val outputPNGFile = new File(s"$path/$name.png")

    // set resolution (in DPI)
    renderer.setResolution(300)
    ImageIO.write(
      renderer.render(doc).get(0).asInstanceOf[RenderedImage],
      "png", outputPNGFile
    )

    outputPNGFile
  }

  /**
    * Save a JPEG generated by the TIKZ picture into the given path.
    *
    * @param path a path to save the generated JPEG
    * @return a Try holding the saved JPEG file. In case of non-fatal
    *         exception, a Failure object is returned holding the exception.
    */
  final def saveAsJPEG(path: String, compiler: Compiler = PDF_LATEX): Try[File] = Try {
    // load PDF document
    val doc = new PDFDocument()
    doc.load(compilePDF(compiler))

    // create renderer
    val renderer = new SimpleRenderer()
    val outputJPEGFile = new File(s"$path/$name.jpeg")

    // set resolution (in DPI)
    renderer.setResolution(300)
    ImageIO.write(
      renderer.render(doc).get(0).asInstanceOf[RenderedImage],
      "jpeg", outputJPEGFile
    )

    outputJPEGFile
  }
}